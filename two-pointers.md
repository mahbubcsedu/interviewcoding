The **Two-Pointer pattern** is a powerful technique that is widely used in solving array and string problems. It involves using two pointers to iterate over the input, often starting from opposite ends of the array or moving together from one end while adjusting their positions based on certain conditions. It is particularly useful for problems related to arrays, linked lists, and strings, where you need to find pairs or subarrays that satisfy specific criteria.

Below is a comprehensive list of problems categorized by difficulty and concept that you can practice to prepare for **Two-Pointer** problems in coding interviews:

---

### **1. Basic Two-Pointer Problems**

These problems involve simple applications of the two-pointer technique, where the goal is often to find pairs or check for certain conditions.

- **Two Sum**
  - Problem: Given an array of integers and a target, find two numbers such that their sum is equal to the target.
  - [Leetcode: Two Sum](https://leetcode.com/problems/two-sum/)
  
- **Two Sum II (Input is Sorted)**
  - Problem: Given a sorted array and a target, return the indices of the two numbers that add up to the target.
  - [Leetcode: Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

- **Move Zeroes**
  - Problem: Given an array, move all zeroes to the end while maintaining the relative order of the non-zero elements.
  - [Leetcode: Move Zeroes](https://leetcode.com/problems/move-zeroes/)

- **Sort Colors (Dutch National Flag Problem)**
  - Problem: Given an array with three distinct values (0, 1, and 2), sort the array without using the built-in sort function.
  - [Leetcode: Sort Colors](https://leetcode.com/problems/sort-colors/)

- **Valid Palindrome**
  - Problem: Given a string, check if it is a palindrome (ignoring non-alphanumeric characters).
  - [Leetcode: Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

---

### **2. Sorting and Searching with Two Pointers**

These problems leverage the two-pointer technique alongside sorting and binary search.

- **Three Sum**
  - Problem: Given an array of integers, find all unique triplets that sum to zero.
  - [Leetcode: Three Sum](https://leetcode.com/problems/3sum/)

- **Two Sum II (Sorted Array)**
  - Problem: Find two numbers in a sorted array that sum up to a target. (You can use a two-pointer approach to find the pair in linear time.)
  - [Leetcode: Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

- **Four Sum**
  - Problem: Given an array of integers, find all unique quadruplets that sum to a target value.
  - [Leetcode: Four Sum](https://leetcode.com/problems/4sum/)

- **Container With Most Water**
  - Problem: Given an array where each element represents the height of a line on a graph, find two lines that together with the x-axis form a container that holds the most water.
  - [Leetcode: Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

---

### **3. String Manipulation with Two Pointers**

These problems involve string manipulation and checking conditions using two pointers.

- **Longest Substring Without Repeating Characters**
  - Problem: Given a string, find the length of the longest substring without repeating characters.
  - [Leetcode: Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

- **Longest Palindromic Substring**
  - Problem: Given a string, return the longest palindromic substring.
  - [Leetcode: Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

- **Find the Index of the First Occurrence of a Substring**
  - Problem: Given a string `haystack` and a string `needle`, find the index of the first occurrence of `needle` in `haystack`.
  - [Leetcode: Str Str](https://leetcode.com/problems/strstr/)

- **Valid Anagram**
  - Problem: Given two strings, check if one is an anagram of the other.
  - [Leetcode: Valid Anagram](https://leetcode.com/problems/valid-anagram/)

---

### **4. Subarray Problems Using Two Pointers**

In these problems, the two-pointer technique is used to find subarrays that satisfy certain conditions.

- **Subarray Sum Equals K**
  - Problem: Given an array of integers and a target sum, find the total number of continuous subarrays whose sum equals the target.
  - [Leetcode: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

- **Maximum Length of Subarray with Positive Product**
  - Problem: Given an array, find the length of the longest subarray with a product greater than 0.
  - [Leetcode: Maximum Length of Subarray with Positive Product](https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/)

- **Subarray Product Less Than K**
  - Problem: Find the number of contiguous subarrays whose product is less than a given target.
  - [Leetcode: Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)

- **Find All Anagrams in a String**
  - Problem: Given two strings, find all starting indices of substrings in a string that are anagrams of another string.
  - [Leetcode: Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

---

### **5. Linked List Problems with Two Pointers**

These problems involve using two pointers to traverse or manipulate linked lists.

- **Linked List Cycle**
  - Problem: Given a linked list, determine if it has a cycle. (Floyd's Tortoise and Hare algorithm)
  - [Leetcode: Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

- **Intersection of Two Linked Lists**
  - Problem: Given two singly linked lists, determine if they intersect and return the node where they intersect.
  - [Leetcode: Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)

- **Merge Two Sorted Lists**
  - Problem: Merge two sorted linked lists into a single sorted list.
  - [Leetcode: Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

- **Reorder List**
  - Problem: Reorder a linked list such that the elements are in the pattern: first → last → second → second last → and so on.
  - [Leetcode: Reorder List](https://leetcode.com/problems/reorder-list/)

---

### **6. Advanced Two-Pointer Problems**

These problems are more challenging and involve more complex uses of the two-pointer technique, often involving dynamic arrays or recursive structures.

- **Trapping Rain Water**
  - Problem: Given an array of integers representing the elevation map, compute how much water it can trap after raining.
  - [Leetcode: Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

- **3Sum Closest**
  - Problem: Given an array of integers and a target value, find three integers whose sum is closest to the target.
  - [Leetcode: 3Sum Closest](https://leetcode.com/problems/3sum-closest/)

- **Smallest Subarray with Sum Greater than or Equal to K**
  - Problem: Given an array and a value `k`, find the smallest subarray whose sum is greater than or equal to `k`.
  - [Leetcode: Smallest Subarray with Sum Greater than or Equal to K](https://leetcode.com/problems/minimum-size-subarray-sum/)

- **Minimum Window Substring**
  - Problem: Given two strings, `s` and `t`, find the smallest substring in `s` that contains all the characters of `t`.
  - [Leetcode: Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

- **Sliding Window Maximum**
  - Problem: Given an array of integers and an integer `k`, find the maximum number in every sliding window of size `k`.
  - [Leetcode: Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

---

### **7. Miscellaneous Two-Pointer Problems**

These problems don't always fit neatly into a category but are great examples of the two-pointer technique.

- **Valid Palindrome II**
  - Problem: Given a string, determine if it can be a palindrome after deleting at most one character.
  - [Leetcode: Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)

- **Merge Intervals**
  - Problem: Given a collection of intervals, merge any overlapping intervals.
  - [Leetcode: Merge Intervals](https://leetcode.com/problems/merge-intervals/)

- **Meeting Rooms II**
  - Problem: Given a set of meeting time intervals, find the minimum number of meeting rooms required.
  - [Leetcode: Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

---

### **Additional Practice Resources**

1. **Leetcode Two-Pointer Problems:**
   - [Leetcode Two-Pointer Problems](https://leetcode.com/tag/two-pointers/)

2. **NeetCode:**
   - [NeetCode Two-Pointer Problems](https://neetcode.io/)



Here’s a comprehensive list of **medium to expert-level problems** that involve the **two-pointer technique**, with one or two solutions for each problem. These problems are sourced from **LeetCode** and other interview prep sites. I’ll include brief descriptions of the problems along with solutions or explanations.

---

### **1. Container With Most Water (LeetCode 11)**  
**Difficulty:** Medium  
**Problem:** Given an array of heights, find the two lines that form a container, such that the container holds the most water. The container's width is the difference between the indices of the two lines, and its height is the smaller of the two lines.

**Solution:**  
- Use two pointers, one at the beginning and one at the end of the array.
- Calculate the area at each step and move the pointer that points to the shorter line, as that has the potential to increase the area.

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        h = min(height[left], height[right])
        max_area = max(max_area, h * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

---

### **2. 3Sum (LeetCode 15)**  
**Difficulty:** Medium  
**Problem:** Find all unique triplets in an array that sum to zero.

**Solution:**  
- Sort the array to make sure we can use the two-pointer technique.
- For each element, treat it as the first element of the triplet and use two pointers to find the other two elements.

```python
def threeSum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue  # Skip duplicates
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1  # Skip duplicates
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1  # Skip duplicates
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result
```

---

### **3. 4Sum (LeetCode 18)**  
**Difficulty:** Medium  
**Problem:** Find all unique quadruplets in an array that sum to the target value.

**Solution:**  
- Similar to the 3Sum problem, but now you need to handle four numbers, so you start with a pointer at each index and use two pointers to find the remaining sum.

```python
def fourSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue  # Skip duplicates
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue  # Skip duplicates
            left, right = j + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1  # Skip duplicates
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1  # Skip duplicates
                    left += 1
                    right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return result
```

---

### **4. Subarray Product Less Than K (LeetCode 713)**  
**Difficulty:** Medium  
**Problem:** Given an array of positive integers and a number k, find how many contiguous subarrays have a product less than k.

**Solution:**  
- Use the sliding window (two-pointer) technique to efficiently count the number of subarrays whose product is less than k.

```python
def numSubarrayProductLessThanK(nums, k):
    left = 0
    product = 1
    count = 0
    for right in range(len(nums)):
        product *= nums[right]
        while product >= k and left <= right:
            product //= nums[left]
            left += 1
        count += right - left + 1
    return count
```

---

### **5. Sort Colors (LeetCode 75)**  
**Difficulty:** Medium  
**Problem:** Given an array with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. You can use the integers 0, 1, and 2 to represent the colors.

**Solution:**  
- Use the **Dutch National Flag problem** approach, which uses three pointers: one for red, one for blue, and one for white.

```python
def sortColors(nums):
    low, mid, high = 0, 0, len(nums) - 1
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
    return nums
```

---

### **6. Valid Palindrome II (LeetCode 680)**  
**Difficulty:** Medium  
**Problem:** Given a string, determine if it can be a palindrome after deleting at most one character.

**Solution:**  
- Use a two-pointer technique to check if a string is a palindrome, and when it isn't, check if deleting one character can help.

```python
def validPalindrome(s):
    def isPalindrome(i, j):
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True
    
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return isPalindrome(left + 1, right) or isPalindrome(left, right - 1)
        left += 1
        right -= 1
    return True
```

---

### **7. Trapping Rain Water (LeetCode 42)**  
**Difficulty:** Hard  
**Problem:** Given n non-negative integers representing the elevation map where the width of each bar is 1, compute how much water it can trap after raining.

**Solution:**  
- Use the two-pointer technique with extra space for maximum heights from left and right.

```python
def trap(height):
    left, right = 0, len(height) - 1
    left_max, right_max = 0, 0
    water = 0
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    return water
```

---

### **8. Maximum Length of Pair Chain (LeetCode 646)**  
**Difficulty:** Medium  
**Problem:** Given a set of pairs, find the length of the longest chain that can be formed where the second element of a pair is strictly greater than the first element of another pair.

**Solution:**  
- Sort the pairs based on the first element, and use a two-pointer approach to find the longest increasing subsequence.

```python
def findLongestChain(pairs):
    pairs.sort(key=lambda x: x[1])
    curr_end = float('-inf')
    count = 0
    for pair in pairs:
        if pair[0] > curr_end:
            count += 1
            curr_end = pair[1]
    return count
```

---

### **9. Minimum Window Substring (LeetCode 76)**  
**Difficulty:** Hard  
**Problem:** Given two strings `s` and `t`, find the minimum window in `s` which will contain all the characters in `t`. 

**Solution:**  
- Use the sliding window approach with two pointers to expand and contract the window to capture all characters in `t`.

```python
from collections import Counter

def minWindow(s, t):
    if not s or not t:
        return ""
    
    t_count = Counter(t)
    s_count = Counter()
    left, right = 0, 0
    min_len = float("inf")
    min_window = ""
    
    while right < len(s):
        s_count[s[right]] += 1
        while all(s_count[char] >= t_count[char] for char in t_count):
            if right - left + 1 < min_len

:
                min_len = right - left + 1
                min_window = s[left:right + 1]
            s_count[s[left]] -= 1
            left += 1
        right += 1
        
    return min_window
```

---

### **10. Reverse Vowels of a String (LeetCode 345)**  
**Difficulty:** Easy  
**Problem:** Write a function that reverses the vowels of a string.

**Solution:**  
- Use two pointers to swap the vowels at the start and end of the string.

```python
def reverseVowels(s):
    vowels = set("aeiouAEIOU")
    s = list(s)
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] in vowels and s[right] in vowels:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
        elif s[left] not in vowels:
            left += 1
        else:
            right -= 1
    return "".join(s)
```

---

These problems will give you plenty of practice with the two-pointer technique at varying levels of difficulty. Some are based on **sliding window** or **sorting** techniques combined with two pointers, and others involve unique use cases like finding pairs or subarrays that meet specific conditions.


### 1574. Shortest Subarray to be Removed to Make Array Sorted
Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.

- Return the length of the shortest subarray to remove.

-A subarray is a contiguous subsequence of the array.

 

** Example 1: **
```python
Input: arr = [1,2,3,10,4,2,3,5]
Output: 3
Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
A tricky problem to practice
```

```python
class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        
        # prefix increasing
        # [1,2,3,1,1,1,2,3]
        n=len(arr)
        r=n-1

        while r>0 and arr[r-1] <=arr[r]:
            r-=1
        res = r

        l=0
        while l < r and (l==0 or arr[l-1] <= arr[l]):
            while r < n and arr[r] < arr[l]:
                r+=1
            res = min(res, r-l-1)
            l+=1
        return res
```
